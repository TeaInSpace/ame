package main

import (
	"bytes"
	"context"
	"log"
	"os"
	"os/exec"
	"path"
	"regexp"
	"strings"
	"testing"
	"time"

	argo "github.com/argoproj/argo-workflows/v3/pkg/client/clientset/versioned/typed/workflow/v1alpha1"
	"github.com/google/go-cmp/cmp"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"

	"github.com/ActiveState/vt10x"
	"github.com/Netflix/go-expect"
	amev1alpha1 "teainspace.com/ame/api/v1alpha1"
	"teainspace.com/ame/controllers"
	"teainspace.com/ame/generated/clientset/versioned/typed/ame/v1alpha1"
	"teainspace.com/ame/internal/dirtools"
	"teainspace.com/ame/server/storage"

	"teainspace.com/ame/internal/config"
)

const (
	testNamespace  = "ame-system"
	testBucketName = "ameprojectstorage"
	cliName        = "ame"
)

var (
	tasks     v1alpha1.TaskInterface
	workflows argo.WorkflowInterface
	ctx       context.Context
)

func kubeClientFromConfig() (*rest.Config, error) {
	configLoadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
	configOverrides := &clientcmd.ConfigOverrides{}
	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(configLoadingRules, configOverrides)
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	return config, nil
}

func workflowsClientFromConfig(cfg *rest.Config, ns string) argo.WorkflowInterface {
	return argo.NewForConfigOrDie(cfg).Workflows(ns)
}

func tasksClientFromConfig(cfg *rest.Config, ns string) v1alpha1.TaskInterface {
	return v1alpha1.NewForConfigOrDie(cfg).Tasks(ns)
}

func clearTasksInCluster() error {
	taskList, err := tasks.List(ctx, v1.ListOptions{})
	if err != nil {
		return err
	}

	for _, ta := range taskList.Items {
		err := tasks.Delete(ctx, ta.GetName(), v1.DeleteOptions{})
		if err != nil {
			return err
		}
	}

	return nil
}

func TestMain(m *testing.M) {
	ctx = context.Background()
	kubeCfg, err := kubeClientFromConfig()
	if err != nil {
		log.Fatal(err)
	}

	workflows = workflowsClientFromConfig(kubeCfg, testNamespace)
	tasks = tasksClientFromConfig(kubeCfg, testNamespace)

	cmd := exec.Command("go", "build", ".")
	err = cmd.Run()
	if err != nil {
		log.Fatal(err)
	}

	exitCode := m.Run()
	// Ensure that the CLI binary is cleanedup.
	os.Remove(cliName)
	os.Exit(exitCode)
}

var localClusterCfg = config.CliConfig{
	AuthToken:   "mytoken",
	AmeEndpoint: "172.18.255.200:3342",
}

// genCliCmd returns a new *exec.Cmd with the path to the
// AME CLI binary built for this test run and with the cmd arguments
// set to cmdArgs.
func genCliCmd(cmdArgs ...string) (*exec.Cmd, error) {
	wd, err := os.Getwd()
	if err != nil {
		return nil, err
	}

	cmd := exec.Command(path.Join(wd, cliName))
	cmd.Args = append([]string{""}, cmdArgs...)

	return cmd, nil
}

func setupStoreage() (*storage.Storage, error) {
	s3Client, err := storage.CreateS3ClientForLocalStorage(ctx)
	if err != nil {
		return nil, err
	}
	store := storage.NewS3Storage(*s3Client, testBucketName)

	// If clear storage fails it does not matter too much
	// as that means the bucket was not present to begin with.
	store.ClearStorage(ctx)

	err = store.PrepareStorage(ctx)
	if err != nil {
		return &store, err
	}

	return &store, nil
}

// matchBuf looks for regex supplied by the parameter pattern in the buffer buf with the
// duration specified by the timeout parameter.
func matchBuf(buf *bytes.Buffer, pattern string, timeout time.Duration) (bool, error) {
	timer := time.NewTimer(timeout)

	for {
		select {
		// A signal from the timer's channel indicates that the timeout duration has passed
		// and the function has therefore failed to find a match for the pattern.
		case <-timer.C:
			return false, nil
		// 10ms loop delays provide enough time for the buffer to have changed,
		// without having excessive delays between each loop.
		default:
			time.Sleep(time.Millisecond * 10)
		}

		matched, err := regexp.MatchString(pattern, buf.String())
		if err != nil {
			return false, err
		}

		if matched {
			return true, nil
		}
	}
}

// virtualConsole Creates an expect.Console which duplicates it's output to buf, configures
// cmd to run within the Console, and returns that Console. The Console acts as a simulated
// TTY allowing for testing TTY applications by writing to Console's stdin and reading from buf.
// As an example the prompts generated by the survey library require a TTY to run and therefore also
// for testing.
func virtualConsole(cmd *exec.Cmd, buf *bytes.Buffer) (*expect.Console, error) {
	c, _, err := vt10x.NewVT10XConsole(expect.WithStdout(buf))
	if err != nil {
		return nil, err
	}

	cmd.Stdin = c.Tty()
	cmd.Stdout = c.Tty()

	return c, nil
}

func TestRun(t *testing.T) {
	err := clearTasksInCluster()
	if err != nil {
		t.Error(err)
	}

	err = config.LoadCliCfgToEnv(localClusterCfg)
	if err != nil {
		t.Error(err)
	}
	defer config.ClearCliCfgFromEnv()

	storePtr, err := setupStoreage()
	if err != nil {
		t.Error(err)
	}
	store := *storePtr

	files := []storage.ProjectFile{
		{
			Path: "somefile.txt",
			Data: []byte("somecontents"),
		},
	}

	testDir, err := dirtools.MkAndPopulateDirTemp("myproject", files)
	if err != nil {
		t.Error(err)
	}
	// The CLI defaults to using the folder name as the project name.
	// Note that the input to MkAndPopulateDirTemp is not the final
	// directory name but only used as prefix for a random name.
	// Hence why exctracting the directory name is necessary.
	projectName := path.Base(testDir)

	testTask := amev1alpha1.Task{
		ObjectMeta: v1.ObjectMeta{
			Name: projectName,
		}, Spec: amev1alpha1.TaskSpec{
			RunCommand: "python test.py",
			ProjectId:  projectName,
		},
	}

	cliCmd, err := genCliCmd("run", testTask.Spec.RunCommand)
	if err != nil {
		t.Error(err)
	}
	cliCmd.Dir = testDir // The CLI expects to be executed from the project directory.
	out, err := cliCmd.CombinedOutput()
	if err != nil {
		t.Error(err)
	}

	if strings.Contains(string(out), "Error") {
		t.Errorf("Got error in CLI output: %s", string(out))
	}

	// Validate the specification of the task generated by the CLI.
	inclusterTask, err := tasks.Get(ctx, projectName, v1.GetOptions{})
	if err != nil {
		t.Error(err)
	}

	if testTask.Spec.RunCommand != inclusterTask.Spec.RunCommand {
		t.Errorf("Run created a task with Spec.RunCommand=%s , but the cli received the run command %s, got the CLI output: %v",
			inclusterTask.Spec.RunCommand,
			testTask.Spec.RunCommand,
			string(out))
	}

	time.Sleep(time.Second * 1)

	// Validate that a Workflow was actually created based on the task.
	wfList, err := workflows.List(ctx, v1.ListOptions{})
	if err != nil {
		t.Error(err)
	}

	if len(wfList.Items) != 1 {
		t.Errorf("Got %d workflows after 1 second, expected %d , \n with CLI output: %s", len(wfList.Items), 1, string(out))
	}

	wf := wfList.Items[0]
	wfRunCmd := controllers.ExtractRunCommand(&wf)
	wfProjectID := controllers.ExtractProjectID(&wf)

	if testTask.Spec.RunCommand != wfRunCmd {
		t.Errorf("Workflow has run command: %s, but expected: %s, got cli output: %s",
			wfRunCmd,
			testTask.Spec.RunCommand,
			out)
	}

	if testTask.Spec.ProjectId != wfProjectID {
		t.Errorf("Workflow has project ID: %s, but expected: %s",
			wfProjectID,
			testTask.Spec.ProjectId)
	}

	storedFiles, err := store.DownloadFiles(ctx, projectName)
	if err != nil {
		t.Error(err)
	}

	diffs := dirtools.DiffFiles(files, storedFiles)
	if len(diffs) > 0 {
		t.Errorf("The CLI uploaded %+v, expected %+v for project %s, diffs: %v\n stdout: %s", storedFiles, files, projectName, diffs, out)
	}

	err = store.ClearStorage(ctx)
	if err != nil {
		t.Error(err)
	}
}

func TestCliSetup(t *testing.T) {
	err := config.PrepTmpCfgDir(config.CliConfig{})
	if err != nil {
		t.Error(err)
	}

	cliCmd, err := genCliCmd("setup")
	if err != nil {
		t.Error(err)
	}

	buf := &bytes.Buffer{}
	c, err := virtualConsole(cliCmd, buf)
	if err != nil {
		t.Error(err)
	}

	defer c.Close()
	go func() {
		c.ExpectEOF()
	}()

	correctCfg := config.CliConfig{AuthToken: "mytoken", AmeEndpoint: "https://myendpoint.com"}

	behavior := []struct {
		Input     string
		ExpOutput string
	}{
		{
			Input:     correctCfg.AuthToken,
			ExpOutput: ".*token*.",
		},
		{
			Input:     correctCfg.AmeEndpoint,
			ExpOutput: ".*Endpoint*.",
		},
	}

	go func() {
		for _, b := range behavior {
			matched, err := matchBuf(buf, b.ExpOutput, time.Millisecond*100)
			if err != nil {
				t.Error(err)
			}

			if !matched {
				t.Errorf("buf.String()=%s, expected output to to match regex %s", buf.String(), b.ExpOutput)
			}

			c.SendLine(b.Input)
		}

		c.SendLine("")
	}()

	err = cliCmd.Run()
	if err != nil {
		t.Error(err)
	}

	time.Sleep(time.Second * 2)

	cfg, err := config.GenCliConfig()
	if err != nil {
		t.Errorf("Got error from config generation %v, with cli output: \n%s", err, buf.String())
	}

	diff := cmp.Diff(cfg, correctCfg)
	if diff != "" {
		t.Errorf("Expected %+v == %+v, but got diff: %s", cfg, correctCfg, diff)
	}
}
